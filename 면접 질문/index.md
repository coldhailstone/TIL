### WAS 와 웹서버의 차이
- Web Server
    - 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 <b>정적인 컨텐츠</b>(.html .jpeg .css 등)를 제공하는 컴퓨터 프로그램
    - HTTP 프로토콜을 기반으로 하여 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스 하는 기능을 담당한다.
    - Ex) Apache Server, Nginx, IIS 등
- WAS (Web Application)
   - DB 조회나 다양한 로직 처리를 요구하는 <b>동적인 컨텐츠</b>를 제공하기 위해 만들어진 Application Server
   - WAS = Web Server + Web Container
   - Ex) Tomcat, JBoss, Jeus, Web Sphere 등
- Web Service Architecture
   - Client -> Web Server -> DB
   - Client -> WAS -> DB
   - Client -> Web Server -> WAS -> DB
- 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성 을 위해 Web Server와 WAS를 분리한다.
---
### HTTP 메소드와 설명
- GET
  - GET 메서드는 특정 리소스의 표시를 요청합니다. GET을 사용하는 요청은 오직 데이터를 받기만 합니다.
- HEAD
  - HEAD 메서드는 GET 메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않습니다.
- POST
  - POST 메서드는 특정 리소스에 엔티티를 제출할 때 쓰입니다. 이는 종종 서버의 상태의 변화나 부작용을 일으킵니다.
- PUT
  - PUT 메서드는 목적 리소스 모든 현재 표시를 요청 payload로 바꿉니다.
- DELETE
  - DELETE 메서드는 특정 리소스를 삭제합니다.
- CONNECT
  - CONNECT 메서드는 목적 리소스로 식별되는 서버로의 터널을 맺습니다.
- OPTIONS
  - OPTIONS 메서드는 목적 리소스의 통신을 설정하는 데 쓰입니다.
- TRACE (en-US)
  - TRACE 메서드는 목적 리소스의 경로를 따라 메시지 loop-back 테스트를 합니다.
- PATCH
  - PATCH 메서드는 리소스의 부분만을 수정하는 데 쓰입니다.
---
### REST(Representational State Transfer) API 의 설명과 장점
- 기본개념
  - 자원을 이름으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.
  - HTTP URI를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
- 장점
  - HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.
  - HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.
  - HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다. (멀티 플랫폼)
  - Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
  - REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
  - 여러가지 서비스 디자인에서 생길 수 있는 문제를 최소화한다.
  - 서버와 클라이언트의 역할을 명확하게 분리한다.
- 특징
  - Server-Client(서버-클라이언트 구조)
  - Stateless(무상태)
  - Cacheable(캐시 처리 가능)
  - Layered System(계층화)
  - Uniform Interface(인터페이스 일관성)
  - Code On Demand(optional)
---
### JWT(JSON WEB TOKEN) 사용 목적
- 기본개념
  -  웹표준 으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인 방식으로 정보를 안전성 있게 전달해줍니다.
- 구조
  - Header, Payload, Signature의 3부분으로 이루어져 있다. Json 형태인 각 부분은 Base64로 인코딩 되어 표현된다. 각 부분을 이어주기 위해 .구분자를 반환한다. Base64는 암호화된 문자열이 아니고, 같은 문자열에 대해 항상 같은 문자열을 반환한다
- 장점
  - JWT 의 주요한 이점은 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요 없습니다.
  - 쿠키를 전달하지 않아도 되므로 쿠키를 사용함으로써 발생하는 취약점이 사라집니다.
  - URL 파라미터와 헤더로 사용
  - 트래픽 대한 부담이 낮음
  - REST 서비스로 제공 가능
  - 내장된 만료
  - 독립적인 JWT
---
### CSS -> position 속성 설명
- static
  - position 속성의 기본값
  - 요소를 나열한 순서대로 배치하며 top, right, bottom, left, z-index 와 같은 속성을 사용할 수 없습니다.
- relative
  - 자기 자신을 기준으로 상대적 위치를 지정할 수 있는 속성값
  - 자기 자신을 기준으로 top, right, bottom, left의 값에 따라 오프셋을 적용합니다.
- absolute
  - 문서의 흐름과 상관없이 left, right, top, bottom 속성값을 이용하여 요소를 위치시키는 속성값입니다. 
  - 기준이 되는 위치는 가장 가까운 부모 요소 혹은 조상 요소 중 position 속성이 relative인 요소입니다.
- fixed
  - absolute 속성값과 마찬가지로 문서의 흐름과 상관없이 위치를 좌표로 결정합니다.
  - 부모 혹은 조상 요소가 아닌 브라우저 창이 기준이 됩니다.
  - 브라우저 창을 어디로 스크롤 하더라도 계속 고정되어 표시되게 됩니다.
- sticky
  - 기준점을 이상을 넘지 않을 때는 relative 포지션처럼 동작하다 그 이상을 넘게 될 시에는 fixed 속성과 같이 동작하게 됩니다.
  - 스크롤이 scroll 박스 밖으로 벗어나게 될 경우에는 그 위치에서 정지하게 됩니다.
---
### HTML(Hyper Text Markup Language) 이란
- 웹 브라우저에 보여줄 내용을 구조화하고 문서끼리 링크하는 것이다.
- 순차적인 기존의 text 에서 벗어나 비순차적인 문서를 만들 수 있게 해주는 언어
  - ex) hyper link
- 태그를 통해 문서의 구조를 표현하는 언어
- 동적 스크립트를 불러올 수 있다.
---
### DOCTYPE HTML 설명
- 웹문서가 어떤 버전의 HTML 언어로 작성되었는지 결정하는 기능
- DTD(Document Type Declaration)를 통해서 현재의 웹문서가 어떤 버전의 HTML 기술로 작성되었는지 웹브라우저에 전달합니다.
- 브라우저에게 HTML 의 버전 및 웹브라우저 내용을 잘 출력할 수 있도록 도와주는 역할
- 선언의 목적은 문서간의 호환성을 높이기 위함입니다.
---
### SSR(Server Side Rendering) CSR(Client Side Rendering) 차이점
- SSR
  - 서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식이다.
  - 서버에서 이미 '렌더 가능한' 상태로 클라이언트에 전달되기 때문에, JS가 다운로드 되는 동안 사용자는 무언가를 보고 있을 수 있다.
- CSR
  - 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다. 클라이언트는 그것을 받아 렌더링을 시작한다.
- 첫 페이지 로딩시간.
  - CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다.
  - SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다. 따라서 평균적으로 SSR이 더 빠르다.
- 나머지 로딩 시간
  - 첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정하자. CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다.
  - SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.
- SEO 대응
  - CSR은 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 자바스크립트가 실행 되어야 meatadata가 바뀌었다.
  - SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.
- 서버 자원 사용
    - SSR이 서버 자원을 더 많이 사용한다. 매번 서버에 요청을 하기 때문이다.
---
### 괄호로 된 입력 값이 올바른지 판별할 수 있는 자료구조는?
  - 입력: ([{}])
  - 출력: true
  - 정답: stack
  - 풀이: 여는 괄호는 배열에 넣고 닫힌 괄호는 비교해서 배열에서 뺀다. 최종적으로 배열이 비어있으면 정답은 true
---
### ES6 문법
- const and let
- Arrow functions(화살표 함수)
- Template Literals(템플릿 리터럴)
- Default parameters(기본 매개 변수)
- Array and object destructing(비구조화 할당)
- Import and export(가져오기 및 내보내기)
- Promises
- Spread operator(확산 연산자)
- Classes
- for…of